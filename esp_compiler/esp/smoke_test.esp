# Complete EBNF Parser Test File
# Tests every possible combination and edge case
# Version 3.0.0 - Maximum Coverage Test

META
version `3.0.0`
ics_version `1.0`
author `parser-test-suite`
date `2024-01-20`
severity `critical`
platform `multi-platform`
description `Comprehensive test of all EBNF grammar rules and edge cases`
compliance_framework `ISO-27001`
tags `complete,test,coverage,validation`
custom_field `custom_value_123`
numeric_field 42
boolean_field true
float_field 3.14159
META_END

DEF
# =============================================================================
# ALL DATA TYPES AND VARIABLE COMBINATIONS
# =============================================================================

VAR string_var string `test_string_value`
VAR int_var int 2147483647
VAR float_var float 123.456789
VAR boolean_var boolean true
VAR binary_var binary `binary_data_content`
VAR record_var record_data `record_structure`
VAR version_var version `1.2.3`
VAR evr_string_var evr_string `1:2.3.4-5.el8`
VAR base_number int 2
VAR multiplied_number int 4

# Variables without initial values
VAR empty_string string
VAR empty_int int
VAR empty_float float
VAR empty_boolean boolean


# =============================================================================
# ALL RUNTIME OPERATIONS WITH ALL PARAMETER TYPES
# =============================================================================

RUN concat_result CONCAT
    VAR string_var
    literal `_separator_`
    literal `.txt`
RUN_END

RUN split_result SPLIT
    VAR string_var
    delimiter `_`
    character `.`
RUN_END

RUN substring_result SUBSTRING
    VAR concat_result
    start 0
    length 10
RUN_END

RUN regex_result REGEX_CAPTURE
    VAR string_var
    pattern `([a-zA-Z]+)_([0-9]+)`
RUN_END

RUN arithmetic_result ARITHMETIC
    VAR base_number
    + 50
    * 2
    - 25
    / 5
    % 3
RUN_END

RUN count_result COUNT
    VAR string_var
RUN_END

RUN unique_result UNIQUE
    VAR string_var
RUN_END

RUN end_result END
RUN_END

RUN merge_result MERGE
    VAR concat_result
    VAR substring_result
RUN_END

RUN extract_result EXTRACT
    OBJ complex_object field_name
RUN_END

# =============================================================================
# STATES WITH ALL OPERATIONS AND DATA TYPES
# =============================================================================

STATE string_operations_state
    text_field string = `exact_match`
    case_insensitive_field string ieq `CASE_TEST`
    case_insensitive_not_field string ine `NOT_MATCH`
    contains_field string contains `partial`
    starts_field string starts `prefix`
    ends_field string ends `suffix`
    not_contains_field string not_contains `exclude`
    not_starts_field string not_starts `bad_prefix`
    not_ends_field string not_ends `bad_suffix`
    pattern_field string pattern_match `^[A-Z]{3}-[0-9]{4}$`
    matches_field string matches `\d{3}-\d{2}-\d{4}`
STATE_END

STATE numeric_operations_state
    equal_int int = 42
    not_equal_int int != 0
    greater_int int > VAR base_number
    less_int int < 1000
    greater_equal_int int >= VAR multiplied_number
    less_equal_int int <= 9999
    equal_float float = 3.14159
    greater_float float > VAR float_var
STATE_END

STATE boolean_operations_state
    true_check boolean = true
    false_check boolean != false
    var_check boolean = VAR boolean_var
STATE_END

STATE version_operations_state
    min_version version >= `1.0.0`
    max_version version < `2.0.0`
    exact_version version = VAR version_var
STATE_END

STATE binary_operations_state
    binary_equals binary = `exact_binary_match`
    binary_contains binary contains `partial_binary`
STATE_END

STATE set_operations_state
    subset_check string subset_of VAR string_var
    superset_check int superset_of VAR int_var
STATE_END

STATE entity_check_state
    all_entities string = `test` all
    at_least_one_entities int > 0 at_least_one
    none_entities boolean = false none
    only_one_entity string = `unique` only_one
STATE_END

# Record datatype state with nested fields
STATE record_operations_state
    record string
        field name.subfield.deepfield string = `nested_value`
        field config.settings.timeout int > 1000 all
        field metadata.version version >= `1.0` at_least_one
        field flags.enabled boolean = true only_one
    record_end
STATE_END

# =============================================================================
# OBJECTS WITH ALL ELEMENT TYPES
# =============================================================================

OBJECT simple_fields_object
    name `simple_object`
    value VAR string_var
    numeric_field VAR int_var
    flag VAR boolean_var
OBJECT_END

OBJECT complex_object
    # Module elements
    module_name `PowerShell.Security`
    verb `Get`
    noun `SecurityPolicy`
    module_id `12345`
    module_version `2.1.0`

    # Complex parameters block
    parameters record_data
        CommandName `Get-SecurityAudit`
        FilterScript `{$_.Severity -eq 'High'}`
        MaxCount 100
        IncludeDetails true
        TimeoutSeconds VAR service_timeout
    parameters_end

    # Complex select block
    select string
        Name `PolicyName`
        Value `PolicyValue`
        Status `EnabledStatus`
        LastModified `ModificationDate`
        Owner `PolicyOwner`
    select_end

    # Behavior with multiple values
    behavior recursive_scan max_depth 10 include_hidden compress_results

    # Filter with multiple state references
    FILTER include
        STATE_REF string_operations_state
        STATE_REF numeric_operations_state
        STATE_REF entity_check_state
    FILTER_END
OBJECT_END

OBJECT minimal_object
    single_field `minimal_value`
OBJECT_END

OBJECT set_object
    SET_REF union_set
OBJECT_END

# =============================================================================
# SET OPERATIONS WITH ALL COMBINATIONS
# =============================================================================

# Union with multiple operands (minimum 1)
SET union_set union
    OBJECT_REF simple_fields_object
    OBJECT_REF complex_object
    OBJECT_REF minimal_object
SET_END

# Intersection with exactly 2 operands (minimum 2)
SET intersection_set intersection
    OBJECT_REF complex_object
    SET_REF union_set
SET_END

# Complement with exactly 2 operands
SET complement_set complement
    SET_REF union_set
    SET_REF intersection_set
SET_END

# Set with inline object
SET inline_object_set union
    OBJECT inline_test_object
        inline_field `inline_value`
        inline_number 999
    OBJECT_END
    OBJECT_REF minimal_object
SET_END

# Set with filter
SET filtered_set union
    OBJECT_REF complex_object
    FILTER exclude
        STATE_REF boolean_operations_state
    FILTER_END
SET_END

# =============================================================================
# CRITERIA WITH ALL TEST SPECIFICATIONS AND NESTING
# =============================================================================

# Main criteria with AND logic
CRI AND

# CTN with all existence checks
CTN existence_check_ctn
    TEST any all AND
    STATE_REF string_operations_state
    OBJECT_REF complex_object
CTN_END

CTN all_check_ctn
    TEST all at_least_one OR
    STATE_REF numeric_operations_state
    OBJECT_REF simple_fields_object
CTN_END

CTN none_check_ctn
    TEST none only_one ONE
    STATE_REF boolean_operations_state
CTN_END

CTN only_one_check_ctn
    TEST only_one all
    STATE_REF entity_check_state
CTN_END

# CTN with complete ordering test
CTN complete_ordering_test
    # 1. TEST (required first)
    TEST any all AND

    # 2. STATE_REF (multiple allowed)
    STATE_REF string_operations_state
    STATE_REF numeric_operations_state
    STATE_REF record_operations_state

    # 3. OBJECT_REF (multiple allowed)
    OBJECT_REF complex_object
    OBJECT_REF simple_fields_object

    # 4. Local STATE (multiple allowed)
    STATE local_state_one
        local_field_1 string = `local_value_1`
        local_field_2 int > 0
    STATE_END

    STATE local_state_two
        local_field_3 boolean = true
        local_field_4 version >= `1.0.0`
    STATE_END

    # 5. Local OBJECT (single only)
    OBJECT local_test_object
        local_obj_field `local_object_value`
        local_obj_number VAR arithmetic_result

        parameters string
            LocalParam1 `value1`
            LocalParam2 VAR string_var
        parameters_end

        select record_data
            LocalSelect1 `select_value1`
            LocalSelect2 `select_value2`
        select_end

        behavior local_scan quick_mode
    OBJECT_END
CTN_END

CRI_END

# Nested criteria with negation
CRI OR true

# Nested CRI block
CRI AND
    CTN nested_inner_ctn
        TEST all all
        STATE_REF set_operations_state
    CTN_END
CRI_END

CTN negated_test_ctn
    TEST none none_satisfy
    STATE negated_local_state
        negated_field string != `unwanted_value`
        negated_number int <= VAR base_number
    STATE_END
CTN_END

CRI_END

# Edge case: minimal valid criteria
CRI AND
CTN minimal_ctn
    TEST any all
    STATE minimal_state
        minimal_field string = `minimal`
    STATE_END
CTN_END
CRI_END

DEF_END
